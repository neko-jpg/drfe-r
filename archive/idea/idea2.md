1. まず「何が起きたか」— 構築中に死ぬ最大原因（ほぼこれ）
(1) Louvain風の角度計算が O(N²) になってる

compute_spectral_angles() の “simplified Louvain” の中で、各ノード i ごとに全ノード j を走査してコミュニティ次数合計を作り直している形になっています（comm_degree を i ループ内で毎回構築）。

ノード数 N=8万級（CAIDA想定）だと
1イテレーションで N×N = 6.4e9 近い操作
それを最大20回… → タイムアウトは当然、メモリ圧迫や watchdog で落ちても不思議じゃない。

(2) 隠れ OOM（クラッシュ）要因：巨大 HashMap/Vec の clone が多い

enable_hyper_press() 側で adjacency を作る段階で clone、さらに build_from_adjacency() で adjacency.clone() しています。
NodeId が String 系だと、キーも Vec も文字列も全部複製されて一気にメモリが跳ねます。タイムアウトではなくOOMクラッシュに寄るパターンが出ます。

つまり今回の “B” は方向性は正しいけど、実装が「全体グラフに対する Louvain のつもりで、実際は N²」になっていて構築で死んでます。

2. まず止血：今日中に “構築が終わる” ようにする最短手
止血案 S1：角度計算を「時間/回数で打ち切ってフォールバック」

Louvain風は 数パスだけ（例: 2〜5）回して、それ以上は切る

切ったら旧方式（BFS順とか）で角度を割り当てる

これで「確実に構築が終わる」ようになります。精度が落ちても、まず死なない。

止血案 S2：Louvainを捨てて Label Propagation (LPA) に置換（超軽い）

LPA は実装が簡単で、たいてい O(E)×(数イテレーション) で終わります。ASグラフ相手だと “角度=類似性” を作る下書きとして十分機能しがち。

各ノード i のラベル = “近傍で最多のラベル” に更新（tie は高次数優先など）

5〜10回回して収束させる

ラベル（コミュニティ）ごとに扇形割当

これだけで構築落ちがほぼ消えます（Louvainより雑だが現実的）。

3. 根治：Louvain風を「本当に O(E)」で動く形にする（推奨）

あなたの狙い（idea1.md の B案）は正しいので、実装だけ正しい Louvain の形に直すのが一番きれいです。

根治の核：comm_degree を “毎回全走査” しない

Louvain の移動評価に必要なのは概ね以下だけです：

deg[i] = k_i

comm_tot[c] = Σ_{v in c} deg[v]（コミュニティ総次数）

e_ic = i からコミュニティ c への辺本数（or 重み和）

これらを維持すれば、ノード移動 1回あたり O(deg(i)) で済み、1パス O(E) になります。

具体的な形（実装指針）

community[i]: usize（所属）

deg[i]: f64

comm_tot[c]: f64 を Vec で保持（初期は comm_tot[i]=deg[i]）

ノード i を動かすとき：

近傍を走査して neighbor_comm_edges[c] += 1 を作る（HashMapでも小さいので許容、最適化するなら scratch Vec で）

comm_tot[cur] -= deg[i]（いったん抜く）

候補 c（近傍コミュニティのみ）を評価して best を選ぶ

comm_tot[best] += deg[i]、community[i]=best

これで “Louvain風” の雰囲気ではなく、ちゃんとスケールするやつになります。

さらに一段効く：コミュニティIDを圧縮（使われてないIDを潰す）

Louvain途中は “空コミュニティ” が大量に出ます。
最後に old_id -> 0..C-1 に詰めると、扇形割当やソートが軽くなります。

4. クラッシュ（OOM）側の根治：データ構造を “index化 + CSR” に寄せる

構築で死ぬもう一つの大玉は clone と HashMap と String です。ここを直すと世界が変わります。

推奨アーキテクチャ

NodeId -> usize の index を1回だけ作る（Vecで逆引き）

adjacency は Vec<Vec<usize>> か、できれば CSR：

offset: Vec<u32>（長さ N+1）

nbrs: Vec<u32>（長さ 2E）

HyperPress 側は Arc<CSR> を参照するだけにして、構築時に巨大 clone をしない。

“最小修正”でも効く案

build_from_adjacency(&HashMap<...>) をやめて build_from_graph(&Graph) にして参照で読む

どうしても HashMap を使うなら：

self.adjacency = adjacency.clone() をやめる（参照保持 or Arc）

NodeId を Arc<str> / intern で共有する

5. A(3-hop) と C(λ自動正規化) も “次の地雷” なので先回りで潰す

今回の「構築中クラッシュ」の主因ではないですが、動き出した後にまた詰みやすいので、同時に手を打つのが得です。

(A) 3-hop local ball 爆発問題

スケールフリーで 3-hop は、始点がハブだと ball が一瞬で巨大化します。
→ k=3を維持するなら、ball サイズに上限を設けるのが必須。

実装案

MAX_BALL_NODES（例 2,000〜10,000）

MAX_BALL_EDGES

上限に当たったら：

それ以上 frontier を展開しない（境界条件として扱う）

もしくは “良さそうなノードだけ残す” Beam に切替（下の案）

Beam 3-hop（おすすめ）

BFS で無制限に広げず、

各深さで d_H(v,t) が小さい順に B 個だけ次へ展開（B=200〜2000など）

これで「3-hopのメリット」だけ取りつつ計算量を固定化できます。

(C) λ自動正規化の軽量化（微調整）

いま sort して range を取ってますが、range だけなら min/max 1パスで十分です（小さい最適化だけど、頻繁に呼ばれると効きます）。
加えて安全策：

adaptive_lambda を [λ_min, λ_max] に clamp（例 0.05〜5.0）

hop ごとに急変しないよう EMA 平滑化（λ ← 0.8λ + 0.2λ_new）

6. 「新アルゴ」提案：Louvainより実装簡単で、角度品質が出やすい解

ここからが “生み出す” パートです。
目的は「角度がコミュニティ/類似性を反映」しつつ 構築が落ちないこと。

新アルゴ X1：Anchor-Sector（ハブアンカー扇形）— 最も堅い

発想：全ノードで重いクラスタリングをしない。
上位ハブだけで骨格コミュニティを作り、その他は吸着させる。

次数上位 H（例 500〜3000）をアンカー集合 A にする

A 上の誘導部分グラフでだけ Louvain/LPA（小さいので軽い）

非アンカー v は「隣接アンカーの多数派コミュニティ」へ割当（なければ 2-hop まで見る）

コミュニティごとに扇形割当、コミュニティ内は BFS/次数順で角度を割る

計算量：ほぼ O(E)
特徴：ASグラフの “ハブ中心性” に合ってて、ルーティング向きの角度になりやすい。

新アルゴ X2：Circular Laplacian Smoothing（円周上の調和写像）

発想：角度を「近傍と近い角度にしたい」というエネルギー最小化で作る。固有ベクトルを直接求めず、円周平均で回す。

初期角度をランダム or BFS で与える

反復：

各ノード i の角度を「近傍角度の circular mean」に更新
（複素数平均：mean = Σ exp(jθ_neighbor)、θ_i = arg(mean)）

ただし全員が一点に潰れないように “軽い反発” or “セクタ固定（コミュニティ単位で中心固定）” を混ぜる

計算量：O(E)×(反復回数 20〜100)
長所：実装が短い、落ちにくい、コミュニティ境界が角度に出やすい
短所：設計次第で収束が遅い（が、落ちるより遥かにマシ）

新アルゴ X3：Community Supergraph Ordering（コミュニティ間配置を賢く）

LPA/Louvainでコミュニティが取れた後、「扇形を円周上のどこに置くか」が効きます。
そこでコミュニティ縮約グラフ Gc（頂点=コミュニティ、辺重み=相互接続数）を作り、

Gc の BFS/DFS 順

あるいは Gc に対して軽いスペクトル（ノード数=コミュニティ数なので小さい）

でコミュニティを円周に並べると、“近いコミュニティが近い角度” になり、ルーティングの局所最小が減ります。
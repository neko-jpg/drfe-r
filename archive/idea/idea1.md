1) まず致命点：半径が Poincaré disk になっていない（スケールが 0.95）

H2Coordinate::hyperbolic_distance() は 双曲半径 r（0..R） を前提に

cosh
⁡
(
𝜁
𝑑
)
=
cosh
⁡
(
𝜁
𝑟
1
)
cosh
⁡
(
𝜁
𝑟
2
)
−
sinh
⁡
(
𝜁
𝑟
1
)
sinh
⁡
(
𝜁
𝑟
2
)
cos
⁡
(
Δ
𝜃
)
cosh(ζd)=cosh(ζr
1
	​

)cosh(ζr
2
	​

)−sinh(ζr
1
	​

)sinh(ζr
2
	​

)cos(Δθ)

を使っています。

ところが build 側は DEFAULT_MAX_RADIUS=0.95 に潰していて、N=78771 の AS グラフに必要な “階層感（中心〜境界）” が消えます。AS みたいなスケールフリーで効く典型スケールは

𝑅
≈
2
𝜁
ln
⁡
𝑁
R≈
ζ
2
	​

lnN

で、N=78771 なら ζ=1 で R≈22.55 です。ここが 0.95 だと、距離がほぼ角度だけで決まり、局所極小（greedy dead-end）が爆増します。

修正案（半径）

R を N から決めて、r を log-degree で配置するだけでまず土台が戻ります。

𝑟
𝑖
=
𝑅
−
2
𝜁
ln
⁡
(
𝑘
𝑖
𝑘
min
⁡
)
r
i
	​

=R−
ζ
2
	​

ln(
k
min
	​

k
i
	​

	​

)

（k=1 の扱いは ln(max(k,1)) などでOK）

2) 角度：いまの “Fiedler” は Fiedler になってない

compute_spectral_angles() は Laplacian 
𝐿
L に対して素朴な power iteration を回していますが、これは 第2固有ベクトル（Fiedler）に収束しません。普通の power iteration が拾うのは最大固有値側です（高周波側）。結果として角度はコミュニティ構造を反映しにくく、greedy で詰みます。

角度の実用的な置き換え（優先順）

A. “2本の固有ベクトル” で円周角を作る（軽量で効く）
Fiedler 1本で並べるより、正規化ラプラシアンの非自明固有ベクトルを2本とって

𝜃
𝑖
=
a
t
a
n
2
(
𝑣
𝑖
(
3
)
,
𝑣
𝑖
(
2
)
)
θ
i
	​

=atan2(v
i
(3)
	​

,v
i
(2)
	​

)

にすると、コミュニティが角度に出やすいです。LaBNE 系（ラプラシアンベースの下書き + HyperMap で仕上げ）もこの系譜です。

Rust 実装のコスト感としては「疎行列×ベクトル（O(E)）」を数十〜数百回。E=723k なら現実的です。

B. Louvain/Leiden → コミュニティごとに扇形割当（実装しやすい）
AS グラフはコミュニティ性が強いので、まず Louvain/Leiden/Infomap でクラスタリングして、各クラスタに円周の区間を割り当て、クラスタ内は BFS順や局所スペクトル順で並べる。これだけでも Fiedler 1本より “角度=類似性” に近づきます。

C. ちゃんとやるなら HyperMap / Mercator 系（最も強い）
角度を「リンク尤度最大化（PSO/Popularity–Similarity）」で推定する系は、AS-level で greedy navigability が高いことが知られています。
（あなたの “半径は次数” 方針とも整合します）

3) Φ（ラプラシアン電位）の式が今だと “ゼロに潰れる” 性質

compute_potential() と compute_local_potential() はどちらも

𝜙
(
𝑢
)
←
1
deg
⁡
(
𝑢
)
∑
𝑣
∈
𝑁
(
𝑢
)
𝜙
(
𝑣
)
,
𝜙
(
𝑡
)
=
0
ϕ(u)←
deg(u)
1
	​

v∈N(u)
∑
	​

ϕ(v),ϕ(t)=0

で、境界条件が target 1点しかないので、反復を回すほど 全体が 0 に近づく（情報が消える） 方向になります。いま “10回だけ回してるから何となく勾配っぽい” ものが出てるだけで、ルーティング用の安定したポテンシャルとしては弱いです。

Φを「距離っぽく」する最小修正：hitting time 型（+1 を入れる）

ランダムウォークの到達時間（expected steps）は

𝜙
(
𝑡
)
=
0
,
𝜙
(
𝑢
)
=
1
+
1
deg
⁡
(
𝑢
)
∑
𝑣
∈
𝑁
(
𝑢
)
𝜙
(
𝑣
)
ϕ(t)=0,ϕ(u)=1+
deg(u)
1
	​

v∈N(u)
∑
	​

ϕ(v)

を満たします。これだと値が潰れず、遠いほど大きくなりやすい。

4) 「局所化Φ」の境界条件はこう置くと効きます

今は “current の2-hop部分グラフ” を切り出して、target が外なら「H²で一番近いノード」を sink にしていますが、AS だとこれが外れやすいです（角度がズレてると特に）。

局所化するなら、Dirichlet 境界をきちんと作るのがコツです。

おすすめ：k-hop ball の “フロンティア” を境界にして Dirichlet

current 周りの k-hop ball 
𝐵
𝑘
(
𝑠
)
B
k
	​

(s) を取る（k=3〜4推奨。2はASだと弱い）

フロンティア 
𝐹
=
{
𝑢
∈
𝐵
𝑘
(
𝑠
)
∣
d
i
s
t
(
𝑠
,
𝑢
)
=
𝑘
}
F={u∈B
k
	​

(s)∣dist(s,u)=k} を境界にする

境界値を “外側の推定距離” で固定する。例えば

𝜙
(
𝑢
)
=
𝑑
𝐻
(
𝑢
,
𝑡
)
(
𝑢
∈
𝐹
)
ϕ(u)=d
H
	​

(u,t)(u∈F)

target が ball 内にいれば 
𝜙
(
𝑡
)
=
0
ϕ(t)=0 も固定
4. 内点だけ Gauss–Seidel（hitting time 型なら 1+avg）で更新

これをやると、Φは「局所で詰んだときに、ball の中でどっち方向に抜ければ H² がまた下がり始めるか」を教える補助関数になります。

5) λ（重み）は “自動正規化” しないと壊れやすい

半径スケールを R≈22.55 に直すと、d_H の典型値が一気に 10〜30 くらいになります。一方 Φ は設計次第でスケールが変わるので、固定 λ=1 は危険です。

すぐ効くやり方

局所 ball 内で

Δ
𝑑
=
m
e
d
i
a
n
(
𝑑
𝐻
)
−
m
i
n
(
𝑑
𝐻
)
Δd=median(d
H
	​

)−min(d
H
	​

)

Δ
𝜙
=
m
e
d
i
a
n
(
𝜙
)
−
m
i
n
(
𝜙
)
Δϕ=median(ϕ)−min(ϕ)

みたいな “レンジ” を取って

𝜆
=
𝛼
⋅
Δ
𝑑
Δ
𝜙
+
𝜖
λ=α⋅
Δϕ+ϵ
Δd
	​


（
𝛼
α=0.3〜1.0）にすると、スケール不一致で Φ が無力/暴走するのを防げます。

6) 失敗時フォールバックが “ランダム未訪問近傍” なのも成功率を落としてる

CAIDA ベンチでは find_best_neighbor_fast() が None のときに、未訪問近傍を適当に選んで進んでますが、これは AS グラフだと簡単に迷子になります。

「表を持たない」方針を崩さずに改善するなら、フォールバックはランダムじゃなくて次のどれかにすると効きます。

Core-escape：半径最小（≒次数最大）近傍へ寄る（ハブに吸い上げ）

2-hop/3-hop lookahead：近傍の近傍まで見て “最小 d_H” を作れる方向へ

局所 BFS（小）：k-hop ball 内で “d_H が下がるノード” までの最短路を1回だけ引いて、その次の1手を返す（計算は ball サイズだけ）